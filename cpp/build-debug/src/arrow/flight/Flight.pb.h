// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Flight.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Flight_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Flight_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Flight_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Flight_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Flight_2eproto;
namespace arrow {
namespace flight {
namespace protocol {
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class ActionType;
struct ActionTypeDefaultTypeInternal;
extern ActionTypeDefaultTypeInternal _ActionType_default_instance_;
class BasicAuth;
struct BasicAuthDefaultTypeInternal;
extern BasicAuthDefaultTypeInternal _BasicAuth_default_instance_;
class Criteria;
struct CriteriaDefaultTypeInternal;
extern CriteriaDefaultTypeInternal _Criteria_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class FlightData;
struct FlightDataDefaultTypeInternal;
extern FlightDataDefaultTypeInternal _FlightData_default_instance_;
class FlightDescriptor;
struct FlightDescriptorDefaultTypeInternal;
extern FlightDescriptorDefaultTypeInternal _FlightDescriptor_default_instance_;
class FlightEndpoint;
struct FlightEndpointDefaultTypeInternal;
extern FlightEndpointDefaultTypeInternal _FlightEndpoint_default_instance_;
class FlightInfo;
struct FlightInfoDefaultTypeInternal;
extern FlightInfoDefaultTypeInternal _FlightInfo_default_instance_;
class HandshakeRequest;
struct HandshakeRequestDefaultTypeInternal;
extern HandshakeRequestDefaultTypeInternal _HandshakeRequest_default_instance_;
class HandshakeResponse;
struct HandshakeResponseDefaultTypeInternal;
extern HandshakeResponseDefaultTypeInternal _HandshakeResponse_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class PutResult;
struct PutResultDefaultTypeInternal;
extern PutResultDefaultTypeInternal _PutResult_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class SchemaResult;
struct SchemaResultDefaultTypeInternal;
extern SchemaResultDefaultTypeInternal _SchemaResult_default_instance_;
class Ticket;
struct TicketDefaultTypeInternal;
extern TicketDefaultTypeInternal _Ticket_default_instance_;
}  // namespace protocol
}  // namespace flight
}  // namespace arrow
PROTOBUF_NAMESPACE_OPEN
template<> ::arrow::flight::protocol::Action* Arena::CreateMaybeMessage<::arrow::flight::protocol::Action>(Arena*);
template<> ::arrow::flight::protocol::ActionType* Arena::CreateMaybeMessage<::arrow::flight::protocol::ActionType>(Arena*);
template<> ::arrow::flight::protocol::BasicAuth* Arena::CreateMaybeMessage<::arrow::flight::protocol::BasicAuth>(Arena*);
template<> ::arrow::flight::protocol::Criteria* Arena::CreateMaybeMessage<::arrow::flight::protocol::Criteria>(Arena*);
template<> ::arrow::flight::protocol::Empty* Arena::CreateMaybeMessage<::arrow::flight::protocol::Empty>(Arena*);
template<> ::arrow::flight::protocol::FlightData* Arena::CreateMaybeMessage<::arrow::flight::protocol::FlightData>(Arena*);
template<> ::arrow::flight::protocol::FlightDescriptor* Arena::CreateMaybeMessage<::arrow::flight::protocol::FlightDescriptor>(Arena*);
template<> ::arrow::flight::protocol::FlightEndpoint* Arena::CreateMaybeMessage<::arrow::flight::protocol::FlightEndpoint>(Arena*);
template<> ::arrow::flight::protocol::FlightInfo* Arena::CreateMaybeMessage<::arrow::flight::protocol::FlightInfo>(Arena*);
template<> ::arrow::flight::protocol::HandshakeRequest* Arena::CreateMaybeMessage<::arrow::flight::protocol::HandshakeRequest>(Arena*);
template<> ::arrow::flight::protocol::HandshakeResponse* Arena::CreateMaybeMessage<::arrow::flight::protocol::HandshakeResponse>(Arena*);
template<> ::arrow::flight::protocol::Location* Arena::CreateMaybeMessage<::arrow::flight::protocol::Location>(Arena*);
template<> ::arrow::flight::protocol::PutResult* Arena::CreateMaybeMessage<::arrow::flight::protocol::PutResult>(Arena*);
template<> ::arrow::flight::protocol::Result* Arena::CreateMaybeMessage<::arrow::flight::protocol::Result>(Arena*);
template<> ::arrow::flight::protocol::SchemaResult* Arena::CreateMaybeMessage<::arrow::flight::protocol::SchemaResult>(Arena*);
template<> ::arrow::flight::protocol::Ticket* Arena::CreateMaybeMessage<::arrow::flight::protocol::Ticket>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace arrow {
namespace flight {
namespace protocol {

enum FlightDescriptor_DescriptorType : int {
  FlightDescriptor_DescriptorType_UNKNOWN = 0,
  FlightDescriptor_DescriptorType_PATH = 1,
  FlightDescriptor_DescriptorType_CMD = 2,
  FlightDescriptor_DescriptorType_FlightDescriptor_DescriptorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FlightDescriptor_DescriptorType_FlightDescriptor_DescriptorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FlightDescriptor_DescriptorType_IsValid(int value);
constexpr FlightDescriptor_DescriptorType FlightDescriptor_DescriptorType_DescriptorType_MIN = FlightDescriptor_DescriptorType_UNKNOWN;
constexpr FlightDescriptor_DescriptorType FlightDescriptor_DescriptorType_DescriptorType_MAX = FlightDescriptor_DescriptorType_CMD;
constexpr int FlightDescriptor_DescriptorType_DescriptorType_ARRAYSIZE = FlightDescriptor_DescriptorType_DescriptorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FlightDescriptor_DescriptorType_descriptor();
template<typename T>
inline const std::string& FlightDescriptor_DescriptorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FlightDescriptor_DescriptorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FlightDescriptor_DescriptorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FlightDescriptor_DescriptorType_descriptor(), enum_t_value);
}
inline bool FlightDescriptor_DescriptorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FlightDescriptor_DescriptorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FlightDescriptor_DescriptorType>(
    FlightDescriptor_DescriptorType_descriptor(), name, value);
}
// ===================================================================

class HandshakeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.HandshakeRequest) */ {
 public:
  inline HandshakeRequest() : HandshakeRequest(nullptr) {}
  ~HandshakeRequest() override;
  explicit PROTOBUF_CONSTEXPR HandshakeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandshakeRequest(const HandshakeRequest& from);
  HandshakeRequest(HandshakeRequest&& from) noexcept
    : HandshakeRequest() {
    *this = ::std::move(from);
  }

  inline HandshakeRequest& operator=(const HandshakeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeRequest& operator=(HandshakeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeRequest* internal_default_instance() {
    return reinterpret_cast<const HandshakeRequest*>(
               &_HandshakeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HandshakeRequest& a, HandshakeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandshakeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandshakeRequest& from) {
    HandshakeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandshakeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.HandshakeRequest";
  }
  protected:
  explicit HandshakeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kProtocolVersionFieldNumber = 1,
  };
  // bytes payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // uint64 protocol_version = 1;
  void clear_protocol_version();
  uint64_t protocol_version() const;
  void set_protocol_version(uint64_t value);
  private:
  uint64_t _internal_protocol_version() const;
  void _internal_set_protocol_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.HandshakeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    uint64_t protocol_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class HandshakeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.HandshakeResponse) */ {
 public:
  inline HandshakeResponse() : HandshakeResponse(nullptr) {}
  ~HandshakeResponse() override;
  explicit PROTOBUF_CONSTEXPR HandshakeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandshakeResponse(const HandshakeResponse& from);
  HandshakeResponse(HandshakeResponse&& from) noexcept
    : HandshakeResponse() {
    *this = ::std::move(from);
  }

  inline HandshakeResponse& operator=(const HandshakeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeResponse& operator=(HandshakeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeResponse* internal_default_instance() {
    return reinterpret_cast<const HandshakeResponse*>(
               &_HandshakeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HandshakeResponse& a, HandshakeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandshakeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandshakeResponse& from) {
    HandshakeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandshakeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.HandshakeResponse";
  }
  protected:
  explicit HandshakeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kProtocolVersionFieldNumber = 1,
  };
  // bytes payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // uint64 protocol_version = 1;
  void clear_protocol_version();
  uint64_t protocol_version() const;
  void set_protocol_version(uint64_t value);
  private:
  uint64_t _internal_protocol_version() const;
  void _internal_set_protocol_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.HandshakeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    uint64_t protocol_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class BasicAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.BasicAuth) */ {
 public:
  inline BasicAuth() : BasicAuth(nullptr) {}
  ~BasicAuth() override;
  explicit PROTOBUF_CONSTEXPR BasicAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasicAuth(const BasicAuth& from);
  BasicAuth(BasicAuth&& from) noexcept
    : BasicAuth() {
    *this = ::std::move(from);
  }

  inline BasicAuth& operator=(const BasicAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicAuth& operator=(BasicAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasicAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasicAuth* internal_default_instance() {
    return reinterpret_cast<const BasicAuth*>(
               &_BasicAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BasicAuth& a, BasicAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(BasicAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasicAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasicAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasicAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasicAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BasicAuth& from) {
    BasicAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.BasicAuth";
  }
  protected:
  explicit BasicAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.BasicAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class ActionType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.ActionType) */ {
 public:
  inline ActionType() : ActionType(nullptr) {}
  ~ActionType() override;
  explicit PROTOBUF_CONSTEXPR ActionType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionType(const ActionType& from);
  ActionType(ActionType&& from) noexcept
    : ActionType() {
    *this = ::std::move(from);
  }

  inline ActionType& operator=(const ActionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionType& operator=(ActionType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionType* internal_default_instance() {
    return reinterpret_cast<const ActionType*>(
               &_ActionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ActionType& a, ActionType& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionType& from) {
    ActionType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.ActionType";
  }
  protected:
  explicit ActionType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.ActionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class Criteria final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Criteria) */ {
 public:
  inline Criteria() : Criteria(nullptr) {}
  ~Criteria() override;
  explicit PROTOBUF_CONSTEXPR Criteria(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Criteria(const Criteria& from);
  Criteria(Criteria&& from) noexcept
    : Criteria() {
    *this = ::std::move(from);
  }

  inline Criteria& operator=(const Criteria& from) {
    CopyFrom(from);
    return *this;
  }
  inline Criteria& operator=(Criteria&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Criteria& default_instance() {
    return *internal_default_instance();
  }
  static inline const Criteria* internal_default_instance() {
    return reinterpret_cast<const Criteria*>(
               &_Criteria_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Criteria& a, Criteria& b) {
    a.Swap(&b);
  }
  inline void Swap(Criteria* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Criteria* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Criteria* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Criteria>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Criteria& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Criteria& from) {
    Criteria::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Criteria* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.Criteria";
  }
  protected:
  explicit Criteria(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpressionFieldNumber = 1,
  };
  // bytes expression = 1;
  void clear_expression();
  const std::string& expression() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expression(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expression();
  PROTOBUF_NODISCARD std::string* release_expression();
  void set_allocated_expression(std::string* expression);
  private:
  const std::string& _internal_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expression(const std::string& value);
  std::string* _internal_mutable_expression();
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Criteria)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expression_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class Action final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() override;
  explicit PROTOBUF_CONSTEXPR Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Action& from) {
    Action::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // bytes body = 2;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Action)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  explicit PROTOBUF_CONSTEXPR Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Result& from) {
    Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyFieldNumber = 1,
  };
  // bytes body = 1;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class SchemaResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.SchemaResult) */ {
 public:
  inline SchemaResult() : SchemaResult(nullptr) {}
  ~SchemaResult() override;
  explicit PROTOBUF_CONSTEXPR SchemaResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaResult(const SchemaResult& from);
  SchemaResult(SchemaResult&& from) noexcept
    : SchemaResult() {
    *this = ::std::move(from);
  }

  inline SchemaResult& operator=(const SchemaResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaResult& operator=(SchemaResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaResult* internal_default_instance() {
    return reinterpret_cast<const SchemaResult*>(
               &_SchemaResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SchemaResult& a, SchemaResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchemaResult& from) {
    SchemaResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.SchemaResult";
  }
  protected:
  explicit SchemaResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 1,
  };
  // bytes schema = 1;
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.SchemaResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class FlightDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.FlightDescriptor) */ {
 public:
  inline FlightDescriptor() : FlightDescriptor(nullptr) {}
  ~FlightDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FlightDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightDescriptor(const FlightDescriptor& from);
  FlightDescriptor(FlightDescriptor&& from) noexcept
    : FlightDescriptor() {
    *this = ::std::move(from);
  }

  inline FlightDescriptor& operator=(const FlightDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightDescriptor& operator=(FlightDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightDescriptor* internal_default_instance() {
    return reinterpret_cast<const FlightDescriptor*>(
               &_FlightDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FlightDescriptor& a, FlightDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightDescriptor& from) {
    FlightDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.FlightDescriptor";
  }
  protected:
  explicit FlightDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FlightDescriptor_DescriptorType DescriptorType;
  static constexpr DescriptorType UNKNOWN =
    FlightDescriptor_DescriptorType_UNKNOWN;
  static constexpr DescriptorType PATH =
    FlightDescriptor_DescriptorType_PATH;
  static constexpr DescriptorType CMD =
    FlightDescriptor_DescriptorType_CMD;
  static inline bool DescriptorType_IsValid(int value) {
    return FlightDescriptor_DescriptorType_IsValid(value);
  }
  static constexpr DescriptorType DescriptorType_MIN =
    FlightDescriptor_DescriptorType_DescriptorType_MIN;
  static constexpr DescriptorType DescriptorType_MAX =
    FlightDescriptor_DescriptorType_DescriptorType_MAX;
  static constexpr int DescriptorType_ARRAYSIZE =
    FlightDescriptor_DescriptorType_DescriptorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DescriptorType_descriptor() {
    return FlightDescriptor_DescriptorType_descriptor();
  }
  template<typename T>
  static inline const std::string& DescriptorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DescriptorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DescriptorType_Name.");
    return FlightDescriptor_DescriptorType_Name(enum_t_value);
  }
  static inline bool DescriptorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DescriptorType* value) {
    return FlightDescriptor_DescriptorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kCmdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated string path = 3;
  int path_size() const;
  private:
  int _internal_path_size() const;
  public:
  void clear_path();
  const std::string& path(int index) const;
  std::string* mutable_path(int index);
  void set_path(int index, const std::string& value);
  void set_path(int index, std::string&& value);
  void set_path(int index, const char* value);
  void set_path(int index, const char* value, size_t size);
  std::string* add_path();
  void add_path(const std::string& value);
  void add_path(std::string&& value);
  void add_path(const char* value);
  void add_path(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_path();
  private:
  const std::string& _internal_path(int index) const;
  std::string* _internal_add_path();
  public:

  // bytes cmd = 2;
  void clear_cmd();
  const std::string& cmd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cmd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* cmd);
  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(const std::string& value);
  std::string* _internal_mutable_cmd();
  public:

  // .arrow.flight.protocol.FlightDescriptor.DescriptorType type = 1;
  void clear_type();
  ::arrow::flight::protocol::FlightDescriptor_DescriptorType type() const;
  void set_type(::arrow::flight::protocol::FlightDescriptor_DescriptorType value);
  private:
  ::arrow::flight::protocol::FlightDescriptor_DescriptorType _internal_type() const;
  void _internal_set_type(::arrow::flight::protocol::FlightDescriptor_DescriptorType value);
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.FlightDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class FlightInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.FlightInfo) */ {
 public:
  inline FlightInfo() : FlightInfo(nullptr) {}
  ~FlightInfo() override;
  explicit PROTOBUF_CONSTEXPR FlightInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightInfo(const FlightInfo& from);
  FlightInfo(FlightInfo&& from) noexcept
    : FlightInfo() {
    *this = ::std::move(from);
  }

  inline FlightInfo& operator=(const FlightInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightInfo& operator=(FlightInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightInfo* internal_default_instance() {
    return reinterpret_cast<const FlightInfo*>(
               &_FlightInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FlightInfo& a, FlightInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightInfo& from) {
    FlightInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.FlightInfo";
  }
  protected:
  explicit FlightInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointFieldNumber = 3,
    kSchemaFieldNumber = 1,
    kFlightDescriptorFieldNumber = 2,
    kTotalRecordsFieldNumber = 4,
    kTotalBytesFieldNumber = 5,
  };
  // repeated .arrow.flight.protocol.FlightEndpoint endpoint = 3;
  int endpoint_size() const;
  private:
  int _internal_endpoint_size() const;
  public:
  void clear_endpoint();
  ::arrow::flight::protocol::FlightEndpoint* mutable_endpoint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arrow::flight::protocol::FlightEndpoint >*
      mutable_endpoint();
  private:
  const ::arrow::flight::protocol::FlightEndpoint& _internal_endpoint(int index) const;
  ::arrow::flight::protocol::FlightEndpoint* _internal_add_endpoint();
  public:
  const ::arrow::flight::protocol::FlightEndpoint& endpoint(int index) const;
  ::arrow::flight::protocol::FlightEndpoint* add_endpoint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arrow::flight::protocol::FlightEndpoint >&
      endpoint() const;

  // bytes schema = 1;
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // .arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
  bool has_flight_descriptor() const;
  private:
  bool _internal_has_flight_descriptor() const;
  public:
  void clear_flight_descriptor();
  const ::arrow::flight::protocol::FlightDescriptor& flight_descriptor() const;
  PROTOBUF_NODISCARD ::arrow::flight::protocol::FlightDescriptor* release_flight_descriptor();
  ::arrow::flight::protocol::FlightDescriptor* mutable_flight_descriptor();
  void set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* flight_descriptor);
  private:
  const ::arrow::flight::protocol::FlightDescriptor& _internal_flight_descriptor() const;
  ::arrow::flight::protocol::FlightDescriptor* _internal_mutable_flight_descriptor();
  public:
  void unsafe_arena_set_allocated_flight_descriptor(
      ::arrow::flight::protocol::FlightDescriptor* flight_descriptor);
  ::arrow::flight::protocol::FlightDescriptor* unsafe_arena_release_flight_descriptor();

  // int64 total_records = 4;
  void clear_total_records();
  int64_t total_records() const;
  void set_total_records(int64_t value);
  private:
  int64_t _internal_total_records() const;
  void _internal_set_total_records(int64_t value);
  public:

  // int64 total_bytes = 5;
  void clear_total_bytes();
  int64_t total_bytes() const;
  void set_total_bytes(int64_t value);
  private:
  int64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.FlightInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arrow::flight::protocol::FlightEndpoint > endpoint_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
    ::arrow::flight::protocol::FlightDescriptor* flight_descriptor_;
    int64_t total_records_;
    int64_t total_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class FlightEndpoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.FlightEndpoint) */ {
 public:
  inline FlightEndpoint() : FlightEndpoint(nullptr) {}
  ~FlightEndpoint() override;
  explicit PROTOBUF_CONSTEXPR FlightEndpoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightEndpoint(const FlightEndpoint& from);
  FlightEndpoint(FlightEndpoint&& from) noexcept
    : FlightEndpoint() {
    *this = ::std::move(from);
  }

  inline FlightEndpoint& operator=(const FlightEndpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightEndpoint& operator=(FlightEndpoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightEndpoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightEndpoint* internal_default_instance() {
    return reinterpret_cast<const FlightEndpoint*>(
               &_FlightEndpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FlightEndpoint& a, FlightEndpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightEndpoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightEndpoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightEndpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightEndpoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightEndpoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightEndpoint& from) {
    FlightEndpoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightEndpoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.FlightEndpoint";
  }
  protected:
  explicit FlightEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 2,
    kTicketFieldNumber = 1,
  };
  // repeated .arrow.flight.protocol.Location location = 2;
  int location_size() const;
  private:
  int _internal_location_size() const;
  public:
  void clear_location();
  ::arrow::flight::protocol::Location* mutable_location(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arrow::flight::protocol::Location >*
      mutable_location();
  private:
  const ::arrow::flight::protocol::Location& _internal_location(int index) const;
  ::arrow::flight::protocol::Location* _internal_add_location();
  public:
  const ::arrow::flight::protocol::Location& location(int index) const;
  ::arrow::flight::protocol::Location* add_location();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arrow::flight::protocol::Location >&
      location() const;

  // .arrow.flight.protocol.Ticket ticket = 1;
  bool has_ticket() const;
  private:
  bool _internal_has_ticket() const;
  public:
  void clear_ticket();
  const ::arrow::flight::protocol::Ticket& ticket() const;
  PROTOBUF_NODISCARD ::arrow::flight::protocol::Ticket* release_ticket();
  ::arrow::flight::protocol::Ticket* mutable_ticket();
  void set_allocated_ticket(::arrow::flight::protocol::Ticket* ticket);
  private:
  const ::arrow::flight::protocol::Ticket& _internal_ticket() const;
  ::arrow::flight::protocol::Ticket* _internal_mutable_ticket();
  public:
  void unsafe_arena_set_allocated_ticket(
      ::arrow::flight::protocol::Ticket* ticket);
  ::arrow::flight::protocol::Ticket* unsafe_arena_release_ticket();

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.FlightEndpoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arrow::flight::protocol::Location > location_;
    ::arrow::flight::protocol::Ticket* ticket_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit PROTOBUF_CONSTEXPR Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Location& from) {
    Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class Ticket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Ticket) */ {
 public:
  inline Ticket() : Ticket(nullptr) {}
  ~Ticket() override;
  explicit PROTOBUF_CONSTEXPR Ticket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ticket(const Ticket& from);
  Ticket(Ticket&& from) noexcept
    : Ticket() {
    *this = ::std::move(from);
  }

  inline Ticket& operator=(const Ticket& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ticket& operator=(Ticket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ticket& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ticket* internal_default_instance() {
    return reinterpret_cast<const Ticket*>(
               &_Ticket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Ticket& a, Ticket& b) {
    a.Swap(&b);
  }
  inline void Swap(Ticket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ticket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ticket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ticket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ticket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ticket& from) {
    Ticket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ticket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.Ticket";
  }
  protected:
  explicit Ticket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketFieldNumber = 1,
  };
  // bytes ticket = 1;
  void clear_ticket();
  const std::string& ticket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ticket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ticket();
  PROTOBUF_NODISCARD std::string* release_ticket();
  void set_allocated_ticket(std::string* ticket);
  private:
  const std::string& _internal_ticket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticket(const std::string& value);
  std::string* _internal_mutable_ticket();
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Ticket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class FlightData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.FlightData) */ {
 public:
  inline FlightData() : FlightData(nullptr) {}
  ~FlightData() override;
  explicit PROTOBUF_CONSTEXPR FlightData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightData(const FlightData& from);
  FlightData(FlightData&& from) noexcept
    : FlightData() {
    *this = ::std::move(from);
  }

  inline FlightData& operator=(const FlightData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightData& operator=(FlightData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightData* internal_default_instance() {
    return reinterpret_cast<const FlightData*>(
               &_FlightData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FlightData& a, FlightData& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightData& from) {
    FlightData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.FlightData";
  }
  protected:
  explicit FlightData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataHeaderFieldNumber = 2,
    kAppMetadataFieldNumber = 3,
    kDataBodyFieldNumber = 1000,
    kFlightDescriptorFieldNumber = 1,
  };
  // bytes data_header = 2;
  void clear_data_header();
  const std::string& data_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_header();
  PROTOBUF_NODISCARD std::string* release_data_header();
  void set_allocated_data_header(std::string* data_header);
  private:
  const std::string& _internal_data_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_header(const std::string& value);
  std::string* _internal_mutable_data_header();
  public:

  // bytes app_metadata = 3;
  void clear_app_metadata();
  const std::string& app_metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_metadata();
  PROTOBUF_NODISCARD std::string* release_app_metadata();
  void set_allocated_app_metadata(std::string* app_metadata);
  private:
  const std::string& _internal_app_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_metadata(const std::string& value);
  std::string* _internal_mutable_app_metadata();
  public:

  // bytes data_body = 1000;
  void clear_data_body();
  const std::string& data_body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_body();
  PROTOBUF_NODISCARD std::string* release_data_body();
  void set_allocated_data_body(std::string* data_body);
  private:
  const std::string& _internal_data_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_body(const std::string& value);
  std::string* _internal_mutable_data_body();
  public:

  // .arrow.flight.protocol.FlightDescriptor flight_descriptor = 1;
  bool has_flight_descriptor() const;
  private:
  bool _internal_has_flight_descriptor() const;
  public:
  void clear_flight_descriptor();
  const ::arrow::flight::protocol::FlightDescriptor& flight_descriptor() const;
  PROTOBUF_NODISCARD ::arrow::flight::protocol::FlightDescriptor* release_flight_descriptor();
  ::arrow::flight::protocol::FlightDescriptor* mutable_flight_descriptor();
  void set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* flight_descriptor);
  private:
  const ::arrow::flight::protocol::FlightDescriptor& _internal_flight_descriptor() const;
  ::arrow::flight::protocol::FlightDescriptor* _internal_mutable_flight_descriptor();
  public:
  void unsafe_arena_set_allocated_flight_descriptor(
      ::arrow::flight::protocol::FlightDescriptor* flight_descriptor);
  ::arrow::flight::protocol::FlightDescriptor* unsafe_arena_release_flight_descriptor();

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.FlightData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_header_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_body_;
    ::arrow::flight::protocol::FlightDescriptor* flight_descriptor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// -------------------------------------------------------------------

class PutResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arrow.flight.protocol.PutResult) */ {
 public:
  inline PutResult() : PutResult(nullptr) {}
  ~PutResult() override;
  explicit PROTOBUF_CONSTEXPR PutResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutResult(const PutResult& from);
  PutResult(PutResult&& from) noexcept
    : PutResult() {
    *this = ::std::move(from);
  }

  inline PutResult& operator=(const PutResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutResult& operator=(PutResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutResult* internal_default_instance() {
    return reinterpret_cast<const PutResult*>(
               &_PutResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PutResult& a, PutResult& b) {
    a.Swap(&b);
  }
  inline void Swap(PutResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutResult& from) {
    PutResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arrow.flight.protocol.PutResult";
  }
  protected:
  explicit PutResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppMetadataFieldNumber = 1,
  };
  // bytes app_metadata = 1;
  void clear_app_metadata();
  const std::string& app_metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_metadata();
  PROTOBUF_NODISCARD std::string* release_app_metadata();
  void set_allocated_app_metadata(std::string* app_metadata);
  private:
  const std::string& _internal_app_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_metadata(const std::string& value);
  std::string* _internal_mutable_app_metadata();
  public:

  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.PutResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HandshakeRequest

// uint64 protocol_version = 1;
inline void HandshakeRequest::clear_protocol_version() {
  _impl_.protocol_version_ = uint64_t{0u};
}
inline uint64_t HandshakeRequest::_internal_protocol_version() const {
  return _impl_.protocol_version_;
}
inline uint64_t HandshakeRequest::protocol_version() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.HandshakeRequest.protocol_version)
  return _internal_protocol_version();
}
inline void HandshakeRequest::_internal_set_protocol_version(uint64_t value) {
  
  _impl_.protocol_version_ = value;
}
inline void HandshakeRequest::set_protocol_version(uint64_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.HandshakeRequest.protocol_version)
}

// bytes payload = 2;
inline void HandshakeRequest::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& HandshakeRequest::payload() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.HandshakeRequest.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandshakeRequest::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.HandshakeRequest.payload)
}
inline std::string* HandshakeRequest::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.HandshakeRequest.payload)
  return _s;
}
inline const std::string& HandshakeRequest::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void HandshakeRequest::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* HandshakeRequest::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* HandshakeRequest::release_payload() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.HandshakeRequest.payload)
  return _impl_.payload_.Release();
}
inline void HandshakeRequest::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.HandshakeRequest.payload)
}

// -------------------------------------------------------------------

// HandshakeResponse

// uint64 protocol_version = 1;
inline void HandshakeResponse::clear_protocol_version() {
  _impl_.protocol_version_ = uint64_t{0u};
}
inline uint64_t HandshakeResponse::_internal_protocol_version() const {
  return _impl_.protocol_version_;
}
inline uint64_t HandshakeResponse::protocol_version() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.HandshakeResponse.protocol_version)
  return _internal_protocol_version();
}
inline void HandshakeResponse::_internal_set_protocol_version(uint64_t value) {
  
  _impl_.protocol_version_ = value;
}
inline void HandshakeResponse::set_protocol_version(uint64_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.HandshakeResponse.protocol_version)
}

// bytes payload = 2;
inline void HandshakeResponse::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& HandshakeResponse::payload() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.HandshakeResponse.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandshakeResponse::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.HandshakeResponse.payload)
}
inline std::string* HandshakeResponse::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.HandshakeResponse.payload)
  return _s;
}
inline const std::string& HandshakeResponse::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void HandshakeResponse::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* HandshakeResponse::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* HandshakeResponse::release_payload() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.HandshakeResponse.payload)
  return _impl_.payload_.Release();
}
inline void HandshakeResponse::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.HandshakeResponse.payload)
}

// -------------------------------------------------------------------

// BasicAuth

// string username = 2;
inline void BasicAuth::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& BasicAuth::username() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.BasicAuth.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasicAuth::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.BasicAuth.username)
}
inline std::string* BasicAuth::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.BasicAuth.username)
  return _s;
}
inline const std::string& BasicAuth::_internal_username() const {
  return _impl_.username_.Get();
}
inline void BasicAuth::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* BasicAuth::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* BasicAuth::release_username() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.BasicAuth.username)
  return _impl_.username_.Release();
}
inline void BasicAuth::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.BasicAuth.username)
}

// string password = 3;
inline void BasicAuth::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& BasicAuth::password() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.BasicAuth.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasicAuth::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.BasicAuth.password)
}
inline std::string* BasicAuth::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.BasicAuth.password)
  return _s;
}
inline const std::string& BasicAuth::_internal_password() const {
  return _impl_.password_.Get();
}
inline void BasicAuth::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* BasicAuth::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* BasicAuth::release_password() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.BasicAuth.password)
  return _impl_.password_.Release();
}
inline void BasicAuth::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.BasicAuth.password)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// ActionType

// string type = 1;
inline void ActionType::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ActionType::type() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.ActionType.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionType::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.ActionType.type)
}
inline std::string* ActionType::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.ActionType.type)
  return _s;
}
inline const std::string& ActionType::_internal_type() const {
  return _impl_.type_.Get();
}
inline void ActionType::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionType::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionType::release_type() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.ActionType.type)
  return _impl_.type_.Release();
}
inline void ActionType::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.ActionType.type)
}

// string description = 2;
inline void ActionType::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ActionType::description() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.ActionType.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionType::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.ActionType.description)
}
inline std::string* ActionType::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.ActionType.description)
  return _s;
}
inline const std::string& ActionType::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ActionType::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionType::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionType::release_description() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.ActionType.description)
  return _impl_.description_.Release();
}
inline void ActionType::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.ActionType.description)
}

// -------------------------------------------------------------------

// Criteria

// bytes expression = 1;
inline void Criteria::clear_expression() {
  _impl_.expression_.ClearToEmpty();
}
inline const std::string& Criteria::expression() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Criteria.expression)
  return _internal_expression();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Criteria::set_expression(ArgT0&& arg0, ArgT... args) {
 
 _impl_.expression_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Criteria.expression)
}
inline std::string* Criteria::mutable_expression() {
  std::string* _s = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Criteria.expression)
  return _s;
}
inline const std::string& Criteria::_internal_expression() const {
  return _impl_.expression_.Get();
}
inline void Criteria::_internal_set_expression(const std::string& value) {
  
  _impl_.expression_.Set(value, GetArenaForAllocation());
}
inline std::string* Criteria::_internal_mutable_expression() {
  
  return _impl_.expression_.Mutable(GetArenaForAllocation());
}
inline std::string* Criteria::release_expression() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Criteria.expression)
  return _impl_.expression_.Release();
}
inline void Criteria::set_allocated_expression(std::string* expression) {
  if (expression != nullptr) {
    
  } else {
    
  }
  _impl_.expression_.SetAllocated(expression, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expression_.IsDefault()) {
    _impl_.expression_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Criteria.expression)
}

// -------------------------------------------------------------------

// Action

// string type = 1;
inline void Action::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Action::type() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Action.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Action::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Action.type)
}
inline std::string* Action::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Action.type)
  return _s;
}
inline const std::string& Action::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Action::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Action::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Action::release_type() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Action.type)
  return _impl_.type_.Release();
}
inline void Action::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Action.type)
}

// bytes body = 2;
inline void Action::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& Action::body() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Action.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Action::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Action.body)
}
inline std::string* Action::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Action.body)
  return _s;
}
inline const std::string& Action::_internal_body() const {
  return _impl_.body_.Get();
}
inline void Action::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* Action::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* Action::release_body() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Action.body)
  return _impl_.body_.Release();
}
inline void Action::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Action.body)
}

// -------------------------------------------------------------------

// Result

// bytes body = 1;
inline void Result::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& Result::body() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Result.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Result::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Result.body)
}
inline std::string* Result::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Result.body)
  return _s;
}
inline const std::string& Result::_internal_body() const {
  return _impl_.body_.Get();
}
inline void Result::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* Result::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* Result::release_body() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Result.body)
  return _impl_.body_.Release();
}
inline void Result::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Result.body)
}

// -------------------------------------------------------------------

// SchemaResult

// bytes schema = 1;
inline void SchemaResult::clear_schema() {
  _impl_.schema_.ClearToEmpty();
}
inline const std::string& SchemaResult::schema() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.SchemaResult.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaResult::set_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.SchemaResult.schema)
}
inline std::string* SchemaResult::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.SchemaResult.schema)
  return _s;
}
inline const std::string& SchemaResult::_internal_schema() const {
  return _impl_.schema_.Get();
}
inline void SchemaResult::_internal_set_schema(const std::string& value) {
  
  _impl_.schema_.Set(value, GetArenaForAllocation());
}
inline std::string* SchemaResult::_internal_mutable_schema() {
  
  return _impl_.schema_.Mutable(GetArenaForAllocation());
}
inline std::string* SchemaResult::release_schema() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.SchemaResult.schema)
  return _impl_.schema_.Release();
}
inline void SchemaResult::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    
  } else {
    
  }
  _impl_.schema_.SetAllocated(schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_.IsDefault()) {
    _impl_.schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.SchemaResult.schema)
}

// -------------------------------------------------------------------

// FlightDescriptor

// .arrow.flight.protocol.FlightDescriptor.DescriptorType type = 1;
inline void FlightDescriptor::clear_type() {
  _impl_.type_ = 0;
}
inline ::arrow::flight::protocol::FlightDescriptor_DescriptorType FlightDescriptor::_internal_type() const {
  return static_cast< ::arrow::flight::protocol::FlightDescriptor_DescriptorType >(_impl_.type_);
}
inline ::arrow::flight::protocol::FlightDescriptor_DescriptorType FlightDescriptor::type() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightDescriptor.type)
  return _internal_type();
}
inline void FlightDescriptor::_internal_set_type(::arrow::flight::protocol::FlightDescriptor_DescriptorType value) {
  
  _impl_.type_ = value;
}
inline void FlightDescriptor::set_type(::arrow::flight::protocol::FlightDescriptor_DescriptorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightDescriptor.type)
}

// bytes cmd = 2;
inline void FlightDescriptor::clear_cmd() {
  _impl_.cmd_.ClearToEmpty();
}
inline const std::string& FlightDescriptor::cmd() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightDescriptor.cmd)
  return _internal_cmd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlightDescriptor::set_cmd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cmd_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightDescriptor.cmd)
}
inline std::string* FlightDescriptor::mutable_cmd() {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightDescriptor.cmd)
  return _s;
}
inline const std::string& FlightDescriptor::_internal_cmd() const {
  return _impl_.cmd_.Get();
}
inline void FlightDescriptor::_internal_set_cmd(const std::string& value) {
  
  _impl_.cmd_.Set(value, GetArenaForAllocation());
}
inline std::string* FlightDescriptor::_internal_mutable_cmd() {
  
  return _impl_.cmd_.Mutable(GetArenaForAllocation());
}
inline std::string* FlightDescriptor::release_cmd() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightDescriptor.cmd)
  return _impl_.cmd_.Release();
}
inline void FlightDescriptor::set_allocated_cmd(std::string* cmd) {
  if (cmd != nullptr) {
    
  } else {
    
  }
  _impl_.cmd_.SetAllocated(cmd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cmd_.IsDefault()) {
    _impl_.cmd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightDescriptor.cmd)
}

// repeated string path = 3;
inline int FlightDescriptor::_internal_path_size() const {
  return _impl_.path_.size();
}
inline int FlightDescriptor::path_size() const {
  return _internal_path_size();
}
inline void FlightDescriptor::clear_path() {
  _impl_.path_.Clear();
}
inline std::string* FlightDescriptor::add_path() {
  std::string* _s = _internal_add_path();
  // @@protoc_insertion_point(field_add_mutable:arrow.flight.protocol.FlightDescriptor.path)
  return _s;
}
inline const std::string& FlightDescriptor::_internal_path(int index) const {
  return _impl_.path_.Get(index);
}
inline const std::string& FlightDescriptor::path(int index) const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightDescriptor.path)
  return _internal_path(index);
}
inline std::string* FlightDescriptor::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightDescriptor.path)
  return _impl_.path_.Mutable(index);
}
inline void FlightDescriptor::set_path(int index, const std::string& value) {
  _impl_.path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightDescriptor.path)
}
inline void FlightDescriptor::set_path(int index, std::string&& value) {
  _impl_.path_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightDescriptor.path)
}
inline void FlightDescriptor::set_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:arrow.flight.protocol.FlightDescriptor.path)
}
inline void FlightDescriptor::set_path(int index, const char* value, size_t size) {
  _impl_.path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:arrow.flight.protocol.FlightDescriptor.path)
}
inline std::string* FlightDescriptor::_internal_add_path() {
  return _impl_.path_.Add();
}
inline void FlightDescriptor::add_path(const std::string& value) {
  _impl_.path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:arrow.flight.protocol.FlightDescriptor.path)
}
inline void FlightDescriptor::add_path(std::string&& value) {
  _impl_.path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:arrow.flight.protocol.FlightDescriptor.path)
}
inline void FlightDescriptor::add_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:arrow.flight.protocol.FlightDescriptor.path)
}
inline void FlightDescriptor::add_path(const char* value, size_t size) {
  _impl_.path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:arrow.flight.protocol.FlightDescriptor.path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlightDescriptor::path() const {
  // @@protoc_insertion_point(field_list:arrow.flight.protocol.FlightDescriptor.path)
  return _impl_.path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlightDescriptor::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:arrow.flight.protocol.FlightDescriptor.path)
  return &_impl_.path_;
}

// -------------------------------------------------------------------

// FlightInfo

// bytes schema = 1;
inline void FlightInfo::clear_schema() {
  _impl_.schema_.ClearToEmpty();
}
inline const std::string& FlightInfo::schema() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlightInfo::set_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightInfo.schema)
}
inline std::string* FlightInfo::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightInfo.schema)
  return _s;
}
inline const std::string& FlightInfo::_internal_schema() const {
  return _impl_.schema_.Get();
}
inline void FlightInfo::_internal_set_schema(const std::string& value) {
  
  _impl_.schema_.Set(value, GetArenaForAllocation());
}
inline std::string* FlightInfo::_internal_mutable_schema() {
  
  return _impl_.schema_.Mutable(GetArenaForAllocation());
}
inline std::string* FlightInfo::release_schema() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightInfo.schema)
  return _impl_.schema_.Release();
}
inline void FlightInfo::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    
  } else {
    
  }
  _impl_.schema_.SetAllocated(schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_.IsDefault()) {
    _impl_.schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightInfo.schema)
}

// .arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
inline bool FlightInfo::_internal_has_flight_descriptor() const {
  return this != internal_default_instance() && _impl_.flight_descriptor_ != nullptr;
}
inline bool FlightInfo::has_flight_descriptor() const {
  return _internal_has_flight_descriptor();
}
inline void FlightInfo::clear_flight_descriptor() {
  if (GetArenaForAllocation() == nullptr && _impl_.flight_descriptor_ != nullptr) {
    delete _impl_.flight_descriptor_;
  }
  _impl_.flight_descriptor_ = nullptr;
}
inline const ::arrow::flight::protocol::FlightDescriptor& FlightInfo::_internal_flight_descriptor() const {
  const ::arrow::flight::protocol::FlightDescriptor* p = _impl_.flight_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::FlightDescriptor&>(
      ::arrow::flight::protocol::_FlightDescriptor_default_instance_);
}
inline const ::arrow::flight::protocol::FlightDescriptor& FlightInfo::flight_descriptor() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.flight_descriptor)
  return _internal_flight_descriptor();
}
inline void FlightInfo::unsafe_arena_set_allocated_flight_descriptor(
    ::arrow::flight::protocol::FlightDescriptor* flight_descriptor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flight_descriptor_);
  }
  _impl_.flight_descriptor_ = flight_descriptor;
  if (flight_descriptor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.FlightInfo.flight_descriptor)
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightInfo::release_flight_descriptor() {
  
  ::arrow::flight::protocol::FlightDescriptor* temp = _impl_.flight_descriptor_;
  _impl_.flight_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightInfo::unsafe_arena_release_flight_descriptor() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightInfo.flight_descriptor)
  
  ::arrow::flight::protocol::FlightDescriptor* temp = _impl_.flight_descriptor_;
  _impl_.flight_descriptor_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightInfo::_internal_mutable_flight_descriptor() {
  
  if (_impl_.flight_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::arrow::flight::protocol::FlightDescriptor>(GetArenaForAllocation());
    _impl_.flight_descriptor_ = p;
  }
  return _impl_.flight_descriptor_;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightInfo::mutable_flight_descriptor() {
  ::arrow::flight::protocol::FlightDescriptor* _msg = _internal_mutable_flight_descriptor();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightInfo.flight_descriptor)
  return _msg;
}
inline void FlightInfo::set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* flight_descriptor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.flight_descriptor_;
  }
  if (flight_descriptor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flight_descriptor);
    if (message_arena != submessage_arena) {
      flight_descriptor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flight_descriptor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flight_descriptor_ = flight_descriptor;
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightInfo.flight_descriptor)
}

// repeated .arrow.flight.protocol.FlightEndpoint endpoint = 3;
inline int FlightInfo::_internal_endpoint_size() const {
  return _impl_.endpoint_.size();
}
inline int FlightInfo::endpoint_size() const {
  return _internal_endpoint_size();
}
inline void FlightInfo::clear_endpoint() {
  _impl_.endpoint_.Clear();
}
inline ::arrow::flight::protocol::FlightEndpoint* FlightInfo::mutable_endpoint(int index) {
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightInfo.endpoint)
  return _impl_.endpoint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arrow::flight::protocol::FlightEndpoint >*
FlightInfo::mutable_endpoint() {
  // @@protoc_insertion_point(field_mutable_list:arrow.flight.protocol.FlightInfo.endpoint)
  return &_impl_.endpoint_;
}
inline const ::arrow::flight::protocol::FlightEndpoint& FlightInfo::_internal_endpoint(int index) const {
  return _impl_.endpoint_.Get(index);
}
inline const ::arrow::flight::protocol::FlightEndpoint& FlightInfo::endpoint(int index) const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.endpoint)
  return _internal_endpoint(index);
}
inline ::arrow::flight::protocol::FlightEndpoint* FlightInfo::_internal_add_endpoint() {
  return _impl_.endpoint_.Add();
}
inline ::arrow::flight::protocol::FlightEndpoint* FlightInfo::add_endpoint() {
  ::arrow::flight::protocol::FlightEndpoint* _add = _internal_add_endpoint();
  // @@protoc_insertion_point(field_add:arrow.flight.protocol.FlightInfo.endpoint)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arrow::flight::protocol::FlightEndpoint >&
FlightInfo::endpoint() const {
  // @@protoc_insertion_point(field_list:arrow.flight.protocol.FlightInfo.endpoint)
  return _impl_.endpoint_;
}

// int64 total_records = 4;
inline void FlightInfo::clear_total_records() {
  _impl_.total_records_ = int64_t{0};
}
inline int64_t FlightInfo::_internal_total_records() const {
  return _impl_.total_records_;
}
inline int64_t FlightInfo::total_records() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.total_records)
  return _internal_total_records();
}
inline void FlightInfo::_internal_set_total_records(int64_t value) {
  
  _impl_.total_records_ = value;
}
inline void FlightInfo::set_total_records(int64_t value) {
  _internal_set_total_records(value);
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightInfo.total_records)
}

// int64 total_bytes = 5;
inline void FlightInfo::clear_total_bytes() {
  _impl_.total_bytes_ = int64_t{0};
}
inline int64_t FlightInfo::_internal_total_bytes() const {
  return _impl_.total_bytes_;
}
inline int64_t FlightInfo::total_bytes() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.total_bytes)
  return _internal_total_bytes();
}
inline void FlightInfo::_internal_set_total_bytes(int64_t value) {
  
  _impl_.total_bytes_ = value;
}
inline void FlightInfo::set_total_bytes(int64_t value) {
  _internal_set_total_bytes(value);
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightInfo.total_bytes)
}

// -------------------------------------------------------------------

// FlightEndpoint

// .arrow.flight.protocol.Ticket ticket = 1;
inline bool FlightEndpoint::_internal_has_ticket() const {
  return this != internal_default_instance() && _impl_.ticket_ != nullptr;
}
inline bool FlightEndpoint::has_ticket() const {
  return _internal_has_ticket();
}
inline void FlightEndpoint::clear_ticket() {
  if (GetArenaForAllocation() == nullptr && _impl_.ticket_ != nullptr) {
    delete _impl_.ticket_;
  }
  _impl_.ticket_ = nullptr;
}
inline const ::arrow::flight::protocol::Ticket& FlightEndpoint::_internal_ticket() const {
  const ::arrow::flight::protocol::Ticket* p = _impl_.ticket_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::Ticket&>(
      ::arrow::flight::protocol::_Ticket_default_instance_);
}
inline const ::arrow::flight::protocol::Ticket& FlightEndpoint::ticket() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightEndpoint.ticket)
  return _internal_ticket();
}
inline void FlightEndpoint::unsafe_arena_set_allocated_ticket(
    ::arrow::flight::protocol::Ticket* ticket) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ticket_);
  }
  _impl_.ticket_ = ticket;
  if (ticket) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.FlightEndpoint.ticket)
}
inline ::arrow::flight::protocol::Ticket* FlightEndpoint::release_ticket() {
  
  ::arrow::flight::protocol::Ticket* temp = _impl_.ticket_;
  _impl_.ticket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::arrow::flight::protocol::Ticket* FlightEndpoint::unsafe_arena_release_ticket() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightEndpoint.ticket)
  
  ::arrow::flight::protocol::Ticket* temp = _impl_.ticket_;
  _impl_.ticket_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::Ticket* FlightEndpoint::_internal_mutable_ticket() {
  
  if (_impl_.ticket_ == nullptr) {
    auto* p = CreateMaybeMessage<::arrow::flight::protocol::Ticket>(GetArenaForAllocation());
    _impl_.ticket_ = p;
  }
  return _impl_.ticket_;
}
inline ::arrow::flight::protocol::Ticket* FlightEndpoint::mutable_ticket() {
  ::arrow::flight::protocol::Ticket* _msg = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightEndpoint.ticket)
  return _msg;
}
inline void FlightEndpoint::set_allocated_ticket(::arrow::flight::protocol::Ticket* ticket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ticket_;
  }
  if (ticket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ticket);
    if (message_arena != submessage_arena) {
      ticket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ticket, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ticket_ = ticket;
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightEndpoint.ticket)
}

// repeated .arrow.flight.protocol.Location location = 2;
inline int FlightEndpoint::_internal_location_size() const {
  return _impl_.location_.size();
}
inline int FlightEndpoint::location_size() const {
  return _internal_location_size();
}
inline void FlightEndpoint::clear_location() {
  _impl_.location_.Clear();
}
inline ::arrow::flight::protocol::Location* FlightEndpoint::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightEndpoint.location)
  return _impl_.location_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arrow::flight::protocol::Location >*
FlightEndpoint::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:arrow.flight.protocol.FlightEndpoint.location)
  return &_impl_.location_;
}
inline const ::arrow::flight::protocol::Location& FlightEndpoint::_internal_location(int index) const {
  return _impl_.location_.Get(index);
}
inline const ::arrow::flight::protocol::Location& FlightEndpoint::location(int index) const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightEndpoint.location)
  return _internal_location(index);
}
inline ::arrow::flight::protocol::Location* FlightEndpoint::_internal_add_location() {
  return _impl_.location_.Add();
}
inline ::arrow::flight::protocol::Location* FlightEndpoint::add_location() {
  ::arrow::flight::protocol::Location* _add = _internal_add_location();
  // @@protoc_insertion_point(field_add:arrow.flight.protocol.FlightEndpoint.location)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arrow::flight::protocol::Location >&
FlightEndpoint::location() const {
  // @@protoc_insertion_point(field_list:arrow.flight.protocol.FlightEndpoint.location)
  return _impl_.location_;
}

// -------------------------------------------------------------------

// Location

// string uri = 1;
inline void Location::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& Location::uri() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Location.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Location.uri)
}
inline std::string* Location::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Location.uri)
  return _s;
}
inline const std::string& Location::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Location::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_uri() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Location.uri)
  return _impl_.uri_.Release();
}
inline void Location::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Location.uri)
}

// -------------------------------------------------------------------

// Ticket

// bytes ticket = 1;
inline void Ticket::clear_ticket() {
  _impl_.ticket_.ClearToEmpty();
}
inline const std::string& Ticket::ticket() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Ticket.ticket)
  return _internal_ticket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ticket::set_ticket(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ticket_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Ticket.ticket)
}
inline std::string* Ticket::mutable_ticket() {
  std::string* _s = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Ticket.ticket)
  return _s;
}
inline const std::string& Ticket::_internal_ticket() const {
  return _impl_.ticket_.Get();
}
inline void Ticket::_internal_set_ticket(const std::string& value) {
  
  _impl_.ticket_.Set(value, GetArenaForAllocation());
}
inline std::string* Ticket::_internal_mutable_ticket() {
  
  return _impl_.ticket_.Mutable(GetArenaForAllocation());
}
inline std::string* Ticket::release_ticket() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Ticket.ticket)
  return _impl_.ticket_.Release();
}
inline void Ticket::set_allocated_ticket(std::string* ticket) {
  if (ticket != nullptr) {
    
  } else {
    
  }
  _impl_.ticket_.SetAllocated(ticket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ticket_.IsDefault()) {
    _impl_.ticket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Ticket.ticket)
}

// -------------------------------------------------------------------

// FlightData

// .arrow.flight.protocol.FlightDescriptor flight_descriptor = 1;
inline bool FlightData::_internal_has_flight_descriptor() const {
  return this != internal_default_instance() && _impl_.flight_descriptor_ != nullptr;
}
inline bool FlightData::has_flight_descriptor() const {
  return _internal_has_flight_descriptor();
}
inline void FlightData::clear_flight_descriptor() {
  if (GetArenaForAllocation() == nullptr && _impl_.flight_descriptor_ != nullptr) {
    delete _impl_.flight_descriptor_;
  }
  _impl_.flight_descriptor_ = nullptr;
}
inline const ::arrow::flight::protocol::FlightDescriptor& FlightData::_internal_flight_descriptor() const {
  const ::arrow::flight::protocol::FlightDescriptor* p = _impl_.flight_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::FlightDescriptor&>(
      ::arrow::flight::protocol::_FlightDescriptor_default_instance_);
}
inline const ::arrow::flight::protocol::FlightDescriptor& FlightData::flight_descriptor() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightData.flight_descriptor)
  return _internal_flight_descriptor();
}
inline void FlightData::unsafe_arena_set_allocated_flight_descriptor(
    ::arrow::flight::protocol::FlightDescriptor* flight_descriptor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flight_descriptor_);
  }
  _impl_.flight_descriptor_ = flight_descriptor;
  if (flight_descriptor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.FlightData.flight_descriptor)
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightData::release_flight_descriptor() {
  
  ::arrow::flight::protocol::FlightDescriptor* temp = _impl_.flight_descriptor_;
  _impl_.flight_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightData::unsafe_arena_release_flight_descriptor() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightData.flight_descriptor)
  
  ::arrow::flight::protocol::FlightDescriptor* temp = _impl_.flight_descriptor_;
  _impl_.flight_descriptor_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightData::_internal_mutable_flight_descriptor() {
  
  if (_impl_.flight_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::arrow::flight::protocol::FlightDescriptor>(GetArenaForAllocation());
    _impl_.flight_descriptor_ = p;
  }
  return _impl_.flight_descriptor_;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightData::mutable_flight_descriptor() {
  ::arrow::flight::protocol::FlightDescriptor* _msg = _internal_mutable_flight_descriptor();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightData.flight_descriptor)
  return _msg;
}
inline void FlightData::set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* flight_descriptor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.flight_descriptor_;
  }
  if (flight_descriptor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flight_descriptor);
    if (message_arena != submessage_arena) {
      flight_descriptor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flight_descriptor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flight_descriptor_ = flight_descriptor;
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightData.flight_descriptor)
}

// bytes data_header = 2;
inline void FlightData::clear_data_header() {
  _impl_.data_header_.ClearToEmpty();
}
inline const std::string& FlightData::data_header() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightData.data_header)
  return _internal_data_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlightData::set_data_header(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_header_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightData.data_header)
}
inline std::string* FlightData::mutable_data_header() {
  std::string* _s = _internal_mutable_data_header();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightData.data_header)
  return _s;
}
inline const std::string& FlightData::_internal_data_header() const {
  return _impl_.data_header_.Get();
}
inline void FlightData::_internal_set_data_header(const std::string& value) {
  
  _impl_.data_header_.Set(value, GetArenaForAllocation());
}
inline std::string* FlightData::_internal_mutable_data_header() {
  
  return _impl_.data_header_.Mutable(GetArenaForAllocation());
}
inline std::string* FlightData::release_data_header() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightData.data_header)
  return _impl_.data_header_.Release();
}
inline void FlightData::set_allocated_data_header(std::string* data_header) {
  if (data_header != nullptr) {
    
  } else {
    
  }
  _impl_.data_header_.SetAllocated(data_header, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_header_.IsDefault()) {
    _impl_.data_header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightData.data_header)
}

// bytes app_metadata = 3;
inline void FlightData::clear_app_metadata() {
  _impl_.app_metadata_.ClearToEmpty();
}
inline const std::string& FlightData::app_metadata() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightData.app_metadata)
  return _internal_app_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlightData::set_app_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_metadata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightData.app_metadata)
}
inline std::string* FlightData::mutable_app_metadata() {
  std::string* _s = _internal_mutable_app_metadata();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightData.app_metadata)
  return _s;
}
inline const std::string& FlightData::_internal_app_metadata() const {
  return _impl_.app_metadata_.Get();
}
inline void FlightData::_internal_set_app_metadata(const std::string& value) {
  
  _impl_.app_metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* FlightData::_internal_mutable_app_metadata() {
  
  return _impl_.app_metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* FlightData::release_app_metadata() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightData.app_metadata)
  return _impl_.app_metadata_.Release();
}
inline void FlightData::set_allocated_app_metadata(std::string* app_metadata) {
  if (app_metadata != nullptr) {
    
  } else {
    
  }
  _impl_.app_metadata_.SetAllocated(app_metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_metadata_.IsDefault()) {
    _impl_.app_metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightData.app_metadata)
}

// bytes data_body = 1000;
inline void FlightData::clear_data_body() {
  _impl_.data_body_.ClearToEmpty();
}
inline const std::string& FlightData::data_body() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightData.data_body)
  return _internal_data_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlightData::set_data_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_body_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightData.data_body)
}
inline std::string* FlightData::mutable_data_body() {
  std::string* _s = _internal_mutable_data_body();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightData.data_body)
  return _s;
}
inline const std::string& FlightData::_internal_data_body() const {
  return _impl_.data_body_.Get();
}
inline void FlightData::_internal_set_data_body(const std::string& value) {
  
  _impl_.data_body_.Set(value, GetArenaForAllocation());
}
inline std::string* FlightData::_internal_mutable_data_body() {
  
  return _impl_.data_body_.Mutable(GetArenaForAllocation());
}
inline std::string* FlightData::release_data_body() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightData.data_body)
  return _impl_.data_body_.Release();
}
inline void FlightData::set_allocated_data_body(std::string* data_body) {
  if (data_body != nullptr) {
    
  } else {
    
  }
  _impl_.data_body_.SetAllocated(data_body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_body_.IsDefault()) {
    _impl_.data_body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightData.data_body)
}

// -------------------------------------------------------------------

// PutResult

// bytes app_metadata = 1;
inline void PutResult::clear_app_metadata() {
  _impl_.app_metadata_.ClearToEmpty();
}
inline const std::string& PutResult::app_metadata() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.PutResult.app_metadata)
  return _internal_app_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutResult::set_app_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_metadata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.PutResult.app_metadata)
}
inline std::string* PutResult::mutable_app_metadata() {
  std::string* _s = _internal_mutable_app_metadata();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.PutResult.app_metadata)
  return _s;
}
inline const std::string& PutResult::_internal_app_metadata() const {
  return _impl_.app_metadata_.Get();
}
inline void PutResult::_internal_set_app_metadata(const std::string& value) {
  
  _impl_.app_metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* PutResult::_internal_mutable_app_metadata() {
  
  return _impl_.app_metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* PutResult::release_app_metadata() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.PutResult.app_metadata)
  return _impl_.app_metadata_.Release();
}
inline void PutResult::set_allocated_app_metadata(std::string* app_metadata) {
  if (app_metadata != nullptr) {
    
  } else {
    
  }
  _impl_.app_metadata_.SetAllocated(app_metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_metadata_.IsDefault()) {
    _impl_.app_metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.PutResult.app_metadata)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace flight
}  // namespace arrow

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::arrow::flight::protocol::FlightDescriptor_DescriptorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arrow::flight::protocol::FlightDescriptor_DescriptorType>() {
  return ::arrow::flight::protocol::FlightDescriptor_DescriptorType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Flight_2eproto
